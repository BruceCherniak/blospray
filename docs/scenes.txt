abstract operations on plugin-provided scene contents:


- update material
- update plugin parameters (or even plugin type)


desirable features:

- different types of ospray scene can be generated by a plugin, as
  the OSPRAY API is fairly limited and certain scenes can only be constructed
  efficiently in a single way (e.g. 8M RBCs). therefore, having a
  strict one-to-one mapping between Blender scene elements (objects
  and object data) and OSPRAY elements is limiting.

- a plugin can provide custom bounding geometry (e.g. bbox or convex 
  hull) to be shown as proxy geometry in blender
  
- a plugin handles scene changes on elements it generated (especially
  during preview rendering), but only for complex scene. if a plugin
  generates only a single piece of geometry a material change should
  be handled by the addon

- a plugin handles useful scene editing on the elements it generated,
  e.g. changing colors or setting a different material
  
- being able to use a Volume dataset as basis for multiple representations 
  in the same scene, so the data doesn't need to be resident multiple times
  
- positioning slice planes on a volume by adding child planes to the 
  volume object/mesh


perhaps the plugin should provide a list of changeable attributes
and internally handle what happens when those get changed. e.g.
rbc_color, plt_color, sphere_radius, enz.


perhaps we should have 3 types of plugins:

- geometry
    - the plugin generates a single Geometry or GeometricModel
    - if the plugin returns a Geometry then appearance (material) is
      set by the user in Blender on a GeometricModel managed by the server
    - if the plugin returns a GeometricModel then appearance needs to
      be set by the plugin. there will only be limited 
      functionality to change the appearance in this case.
      perhaps it is useful to be able to override/set the material on the
      GeometricModel. but setting/editing a prim.materialID list is too much
    - should plugin allow changing colors in this case? for example, 
      by letting the user choose a color map
- volume
    - the plugin generates a single Volume (or VolumetricModel)
    - Volume: samplingrate and TF set on blender side by user
    - VolumetricModel: sampling rate and TF set by plugin
    - would like to support use case where a single Volume is the basis
      of multiple VolumetricModels (e.g. with differing sample rates or TFs)
- scene
    - no limit of generated OSPRAY scene elements
    - the plugin generates a list of (Instance, xform) pairs
    - a (proxy) mesh is used in the blender scene to place the plugin-generated
      objects, by applying the Blender object transform to the
      instance xforms
    - the plugin can publish a number of attributes that can be edited
      by the user in blender. the plugin will need to implement handling
      of changes to these values



challenges:

- In OSPRAY appearence information is stored in GeometricModel and
  VolumetricModel, while the geometry/volume being shown is stored
  in Geometry resp. Volume.

  We want to have proxy geometry for both a Geometry as well as a Volume.
  Which would need to be stored in a Mesh Data node.
  
  In Blender a material is linked to Object Data (i.e. Mesh Data) by
  default. However, this can be changed *per object*. 
  
  Reusing a Geometry/Volume in the scene, for example to show different
  materials/TFs of the same object, would involve linking multiple Objects
  to the same Object Data.
  
  But since materials/TFs are linked to the Object Data we can't
  vary them between Objects.
  
  Using an empty as a child to set some properties is a nice idea,
  but doesn't give the option of using proxy geometry. The child
  would have to be a full mesh for that, but that introduces both
  a mesh object and mesh data. Plus, an empty/object can't be parented
  to more than one object, while object data CAN. 
  
  For volumes a similar situation exists, as the TF and sample rate
  are set on VolumetricModel. So to vary those we can't store them in
  a Mesh Data node, but it needs to be higher in the hierarchy, i.e.
  Mesh Object. But having the TF linked to the Object doesn't really
  fit well with the regular material link to object data.
  
  Doh!
  
  The real challenge is how to map OSPRAY's multiple levels of elements
  onto Blender's 2-level hierarchy of Object + Object Data. While still
  allowing many of the use cases we envision.
  
  Blender Object Data + Material = OSPRAY Geometry + GeometricModel + Material
  Blender Object Data + Material != OSPRAY Volume + VolumetricModel + TF


open questions:

- best way to set a TF for a volumetric model?
    - reuse existing shader nodes, but interpret them differently?
    - create custom shader nodes?


ideas:

- allow a particle system to be used as "spheres" geometry



cosmogrid points
----------------

"spheres" Geometry, with per-sphere color information in the
GeometricModel

color would be fixed, unless changing color mapping would be allowed,
in which case the plugin needs to receive a color map and generate
new colors (+ opacities?) for the 16M points


rbc 8M cells
----------------

two Group -> GeometricModel -> Geometry("triangles") hierarchies,
one for an RBC cell, one for a PLT cell

7.8M instances of the RBC Group, 0.2M instances of the PLT Group
represented as a list of (Group, xform) pairs

placement of the model is done by applying the matrix_world from 
the blender scene to the individual xform matrices on the Instances 
created by the server. if placement is updated all transformations
need to be recomputed

the material set on the RBC and PLT GeometricModel should be changeable.
however, should it be possible to give the RBCs and PLTs *different*
materials? As that would require a way to set them separately from Blender.
Much better to have the user use two separate objects using the same
plugin (one for RBCs, one for PLTs)


cosmogrid raw volume
----------------------

the plugin returns a Volume, based on the .raw file

editing of the transfer function from Blender is desirable.
but TF is set on VolumetricModel


nice to have: being able to show the same volume twice but with
different TFs, without having to load the same volume data twice.
this can easily be done by having one Volume in the scene, with two
different Instance -> Group -> VolumetricModel hierarchies referencing
the same Volume.


disney moana?
--------------

plugin creates full scene as a list of Instance's

materials are set on all elements, etc.

blender is mostly used for camera positioning, render settings, etc

